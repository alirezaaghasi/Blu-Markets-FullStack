
# Blu Markets — Architecture Refactor Spec (v3.1 Final)

**Goal:** Make the running app a **thin UI shell** over a **single, deterministic portfolio engine**.  
**Non-goal:** UI polish, styling, real market pricing.

This spec is implementation-ready:
- All code blocks are **syntactically valid JavaScript** (ES2020+).
- Every action is specified with **preview → validate → classify → confirm → commit → ledger**.
- No duplicate sources of truth are allowed.

---

## 0) Golden Rules (Non-Negotiable)

1. **Single Source of Truth**
   - Portfolio state lives in: `src/state/reducer.js` + `src/state/initialState.js`
   - All computations live in: `src/engine/*`
   - UI never mutates state directly; it only dispatches actions.

2. **Two Boundary Layers**
   - **Portfolio Status** (where you are): `BALANCED | SLIGHTLY_OFF | ATTENTION_REQUIRED`
   - **Action Boundary** (what this action implies): `SAFE | DRIFT | STRUCTURAL | STRESS`

3. **Hard Physics vs Soft Friction**
   - **Mechanical validation** blocks impossible actions (cash, frozen collateral, max LTV…)
   - **Action boundary** never blocks; it adds friction + copy.

4. **Every Commit Writes to the Ledger**
   - If it doesn't write a ledger entry, it didn't happen.

5. **Chat is a Surface, Not a Brain**
   - Chat may collect inputs, show preview, ask confirm.
   - Chat must never invent behavior or "reason" outside deterministic engine output.

6. **Cash is Separate from Layer Allocation**
   - Layer percentages reflect invested holdings only.
   - Cash is tracked and displayed separately.

---

## 1) Locked Domain (Assets, Currency, Layers)

### 1.1 Currency

All values are integers in **IRR**.

### 1.2 Asset Universe (locked)

```js
export const ASSETS = [
  "USDT",
  "IRR_FIXED_INCOME",
  "GOLD",
  "BTC",
  "ETH",
  "QQQ",
  "SOL",
  "TON",
];
```

### 1.3 Layer Mapping (locked)

```js
export const ASSET_LAYER = {
  // Foundation (Stable)
  USDT: "FOUNDATION",
  IRR_FIXED_INCOME: "FOUNDATION",
  
  // Growth (Balanced)
  GOLD: "GROWTH",
  BTC: "GROWTH",
  QQQ: "GROWTH",
  
  // Upside (Volatile)
  ETH: "UPSIDE",
  SOL: "UPSIDE",
  TON: "UPSIDE",
};
```

### 1.4 Default Layer Ranges (display + boundaries)

```js
export const LAYER_RANGES = {
  FOUNDATION: { min: 40, max: 70, hardMin: 30 },
  GROWTH: { min: 20, max: 45 },
  UPSIDE: { min: 0, max: 20, hardMax: 25 },
};
```

---

## 2) State Model (Authoritative)

### 2.1 Types (JSDoc)

```js
/**
 * @typedef {"FOUNDATION"|"GROWTH"|"UPSIDE"} Layer
 * @typedef {"BALANCED"|"SLIGHTLY_OFF"|"ATTENTION_REQUIRED"} PortfolioStatus
 * @typedef {"SAFE"|"DRIFT"|"STRUCTURAL"|"STRESS"} ActionBoundary
 *
 * @typedef {Object} Holding
 * @property {string} assetId
 * @property {number} valueIRR
 * @property {boolean} frozen
 *
 * @typedef {Object} Protection
 * @property {string} id
 * @property {string} assetId
 * @property {number} notionalIRR
 * @property {number} premiumIRR
 * @property {string} startISO
 * @property {string} endISO
 *
 * @typedef {Object} Loan
 * @property {number} amountIRR
 * @property {string} collateralAssetId
 * @property {number} ltv
 * @property {number} liquidationIRR
 * @property {string} startISO
 *
 * @typedef {Object} LedgerEntry
 * @property {string} id
 * @property {string} tsISO
 * @property {string} type
 * @property {Object} details
 *
 * @typedef {Object} Snapshot
 * @property {number} totalIRR
 * @property {number} holdingsIRR
 * @property {number} cashIRR
 * @property {Object<string, number>} holdingsIRRByAsset
 * @property {Object<Layer, number>} layerPct
 * @property {Object<Layer, number>} layerIRR
 *
 * @typedef {Object} MechanicalValidation
 * @property {boolean} ok
 * @property {string[]} errors
 * @property {Object} [meta]
 *
 * @typedef {Object} PendingAction
 * @property {"ADD_FUNDS"|"TRADE"|"PROTECT"|"BORROW"|"REPAY"|"REBALANCE"} kind
 * @property {Object} payload
 * @property {Snapshot} before
 * @property {Snapshot} after
 * @property {MechanicalValidation} validation
 * @property {ActionBoundary} boundary
 * @property {string[]} frictionCopy
 *
 * @typedef {Object} AppState
 * @property {"ONBOARDING_PHONE"|"ONBOARDING_QUESTIONNAIRE"|"ONBOARDING_RESULT"|"ACTIVE"} stage
 * @property {string|null} phone
 * @property {number} cashIRR
 * @property {Holding[]} holdings
 * @property {Object<Layer, number>} targetLayerPct
 * @property {Protection[]} protections
 * @property {Loan|null} loan
 * @property {LedgerEntry[]} ledger
 * @property {PendingAction|null} pendingAction
 * @property {boolean} stressMode
 */
```

### 2.2 Initial State (`src/state/initialState.js`)

```js
import { ASSETS } from "./domain.js";

export const initialState = {
  stage: "ONBOARDING_PHONE",
  phone: null,
  cashIRR: 0,
  holdings: ASSETS.map((a) => ({ assetId: a, valueIRR: 0, frozen: false })),
  targetLayerPct: { FOUNDATION: 50, GROWTH: 35, UPSIDE: 15 },
  protections: [],
  loan: null,
  ledger: [],
  pendingAction: null,
  stressMode: false,
};
```

---

## 3) Engine Modules (Pure Functions Only)

### 3.1 Snapshot (`src/engine/snapshot.js`)

Cash is **excluded** from layer allocation. Layer percentages reflect invested holdings only.

```js
import { ASSET_LAYER } from "../state/domain.js";

export function computeSnapshot(state) {
  const holdingsIRRByAsset = {};
  let holdingsTotal = 0;

  for (const h of state.holdings) {
    holdingsIRRByAsset[h.assetId] = h.valueIRR;
    holdingsTotal += h.valueIRR;
  }

  // Total includes cash (for display), but layer calc excludes cash
  const totalIRR = holdingsTotal + state.cashIRR;

  // Layer allocation based on holdings only (cash excluded)
  const layerIRR = { FOUNDATION: 0, GROWTH: 0, UPSIDE: 0 };
  for (const h of state.holdings) {
    layerIRR[ASSET_LAYER[h.assetId]] += h.valueIRR;
  }

  // Layer percentages based on holdings total (not total with cash)
  const layerPct = {
    FOUNDATION: holdingsTotal ? (layerIRR.FOUNDATION / holdingsTotal) * 100 : 0,
    GROWTH: holdingsTotal ? (layerIRR.GROWTH / holdingsTotal) * 100 : 0,
    UPSIDE: holdingsTotal ? (layerIRR.UPSIDE / holdingsTotal) * 100 : 0,
  };

  return {
    totalIRR,                    // Holdings + Cash (total portfolio value)
    holdingsIRR: holdingsTotal,  // Holdings only
    cashIRR: state.cashIRR,      // Cash separate
    holdingsIRRByAsset,
    layerPct,                    // Based on holdings only
    layerIRR,                    // Based on holdings only
  };
}
```

### 3.2 Portfolio Status (`src/engine/portfolioStatus.js`)

```js
import { LAYER_RANGES } from "../state/domain.js";

export function computePortfolioStatus(layerPct) {
  const issues = [];

  if (layerPct.FOUNDATION < LAYER_RANGES.FOUNDATION.min) issues.push("FOUNDATION_BELOW_TARGET");
  if (layerPct.FOUNDATION > LAYER_RANGES.FOUNDATION.max) issues.push("FOUNDATION_ABOVE_TARGET");
  if (layerPct.UPSIDE > LAYER_RANGES.UPSIDE.max) issues.push("UPSIDE_ABOVE_TARGET");

  const hardIssues = [];
  if (layerPct.FOUNDATION < LAYER_RANGES.FOUNDATION.hardMin) hardIssues.push("FOUNDATION_BELOW_HARD_FLOOR");
  if (layerPct.UPSIDE > LAYER_RANGES.UPSIDE.hardMax) hardIssues.push("UPSIDE_ABOVE_HARD_CAP");

  if (hardIssues.length) return { status: "ATTENTION_REQUIRED", issues: [...issues, ...hardIssues] };
  if (issues.length) return { status: "SLIGHTLY_OFF", issues };
  return { status: "BALANCED", issues: [] };
}
```

### 3.3 Mechanical Validation (`src/engine/validate.js`)

All mechanical validation happens at **Preview** time, including premium cash sufficiency.

```js
import { calcPremiumIRR } from "./pricing.js";

export function ok(meta = {}) {
  return { ok: true, errors: [], meta };
}

export function fail(errors, meta = {}) {
  return { ok: false, errors: Array.isArray(errors) ? errors : [String(errors)], meta };
}

export function validateAddFunds({ amountIRR }) {
  if (!Number.isFinite(amountIRR) || amountIRR <= 0) return fail("INVALID_AMOUNT");
  return ok();
}

export function validateTrade({ side, assetId, amountIRR }, state) {
  if (!["BUY", "SELL"].includes(side)) return fail("INVALID_SIDE");
  if (!state.holdings.some((h) => h.assetId === assetId)) return fail("INVALID_ASSET");
  if (!Number.isFinite(amountIRR) || amountIRR <= 0) return fail("INVALID_AMOUNT");

  const h = state.holdings.find((x) => x.assetId === assetId);
  if (!h) return fail("INVALID_ASSET");

  if (side === "BUY") {
    if (state.cashIRR < amountIRR) {
      return fail(["INSUFFICIENT_CASH"], { required: amountIRR, available: state.cashIRR });
    }
    return ok();
  }

  // SELL
  if (h.frozen) return fail("ASSET_FROZEN");
  if (h.valueIRR < amountIRR) {
    return fail(["INSUFFICIENT_ASSET_VALUE"], { available: h.valueIRR });
  }
  return ok();
}

export function validateProtect({ assetId, months }, state) {
  // Asset validation
  if (!state.holdings.some((h) => h.assetId === assetId)) {
    return fail("INVALID_ASSET");
  }

  // Duration validation
  if (!Number.isFinite(months) || months < 1 || months > 6) {
    return fail("INVALID_MONTHS");
  }

  // Notional validation
  const h = state.holdings.find((x) => x.assetId === assetId);
  if (!h || h.valueIRR <= 0) {
    return fail("NO_NOTIONAL");
  }

  // Premium cash sufficiency check (at preview time for immediate feedback)
  const premium = calcPremiumIRR({
    assetId,
    notionalIRR: h.valueIRR,
    months,
  });

  if (premium > state.cashIRR) {
    return fail(
      ["INSUFFICIENT_CASH_FOR_PREMIUM"],
      { required: premium, available: state.cashIRR }
    );
  }

  return ok();
}

export function validateBorrow({ assetId, amountIRR, ltv }, state) {
  if (!state.holdings.some((h) => h.assetId === assetId)) return fail("INVALID_ASSET");
  if (!Number.isFinite(amountIRR) || amountIRR <= 0) return fail("INVALID_AMOUNT");
  if (!Number.isFinite(ltv) || ltv < 0.2 || ltv > 0.7) return fail("INVALID_LTV");
  if (state.loan) return fail("LOAN_ALREADY_ACTIVE");

  const h = state.holdings.find((x) => x.assetId === assetId);
  if (!h) return fail("INVALID_ASSET");
  if (h.frozen) return fail("ASSET_ALREADY_FROZEN");

  const maxBorrow = Math.floor(h.valueIRR * ltv);
  if (amountIRR > maxBorrow) {
    return fail(["EXCEEDS_MAX_BORROW"], { maxBorrow });
  }
  return ok();
}

export function validateRepay({ amountIRR }, state) {
  if (!state.loan) return fail("NO_ACTIVE_LOAN");
  if (!Number.isFinite(amountIRR) || amountIRR <= 0) return fail("INVALID_AMOUNT");
  if (state.cashIRR <= 0) return fail("NO_CASH");
  return ok();
}

export function validateRebalance({ mode }) {
  if (!["HOLDINGS_ONLY", "HOLDINGS_PLUS_CASH"].includes(mode)) return fail("INVALID_MODE");
  return ok();
}
```

### 3.4 Deterministic Pricing (`src/engine/pricing.js`)

**Note:** These are prototype rates, not real market pricing.

```js
import { ASSET_LAYER } from "../state/domain.js";

export function baseRateForAsset(assetId) {
  const layer = ASSET_LAYER[assetId];
  if (layer === "FOUNDATION") return 0.004;
  if (layer === "GROWTH") return 0.008;
  return 0.012;
}

export function calcPremiumIRR({ assetId, notionalIRR, months }) {
  const rate = baseRateForAsset(assetId);
  return Math.max(0, Math.floor(notionalIRR * rate * months));
}

export function calcLiquidationIRR({ amountIRR, ltv }) {
  return Math.floor(amountIRR / ltv);
}
```

### 3.5 Action Boundary + Copy (`src/engine/boundary.js`)

```js
import { computePortfolioStatus } from "./portfolioStatus.js";

export function classifyActionBoundary({ kind, validation, before, after, stressMode }) {
  if (!validation.ok) return "SAFE";

  const beforeStatus = computePortfolioStatus(before.layerPct);
  const afterStatus = computePortfolioStatus(after.layerPct);

  const escalate = (b) => {
    if (!stressMode) return b;
    if (b === "SAFE") return "DRIFT";
    if (b === "DRIFT") return "STRUCTURAL";
    if (b === "STRUCTURAL") return "STRESS";
    return "STRESS";
  };

  // Rebalance can be "STRUCTURAL" if it fails to improve (e.g. constraints).
  if (kind === "REBALANCE") {
    const improved = afterStatus.issues.length < beforeStatus.issues.length;
    return escalate(improved ? "SAFE" : "STRUCTURAL");
  }

  if (kind === "ADD_FUNDS") return escalate("SAFE");

  if (kind === "REPAY") {
    if (afterStatus.status === "ATTENTION_REQUIRED") return escalate("STRUCTURAL");
    if (afterStatus.status === "SLIGHTLY_OFF") return escalate("DRIFT");
    return escalate("SAFE");
  }

  if (afterStatus.status === "ATTENTION_REQUIRED") return escalate("STRUCTURAL");
  if (afterStatus.status === "SLIGHTLY_OFF") return escalate("DRIFT");
  return escalate("SAFE");
}

export function frictionCopyForBoundary(boundary) {
  if (boundary === "SAFE") return [];
  if (boundary === "DRIFT") return ["This moves you away from your target allocation. You can proceed or rebalance later."];
  if (boundary === "STRUCTURAL") return ["This crosses a structural boundary. You can proceed, but you must acknowledge it."];
  return ["Stress mode: you're making a high-pressure decision. Confirm only if you understand the consequences."];
}
```

---

## 4) Preview Simulators (Pure, No Side Effects)

**Rule:** Preview functions must return a new state clone. No mutation.

`src/engine/preview.js`

```js
import { computeSnapshot } from "./snapshot.js";
import { calcPremiumIRR, calcLiquidationIRR } from "./pricing.js";
import { ASSET_LAYER } from "../state/domain.js";

export function cloneState(state) {
  return {
    ...state,
    holdings: state.holdings.map((h) => ({ ...h })),
    protections: state.protections.map((p) => ({ ...p })),
    loan: state.loan ? { ...state.loan } : null,
    ledger: state.ledger.slice(),
    pendingAction: null,
  };
}

export function previewAddFunds(state, { amountIRR }) {
  const next = cloneState(state);
  next.cashIRR += amountIRR;
  return next;
}

export function previewTrade(state, { side, assetId, amountIRR }) {
  const next = cloneState(state);
  const h = next.holdings.find((x) => x.assetId === assetId);
  if (!h) return next;

  if (side === "BUY") {
    next.cashIRR -= amountIRR;
    h.valueIRR += amountIRR;
  } else {
    h.valueIRR -= amountIRR;
    next.cashIRR += amountIRR;
  }
  return next;
}

export function previewProtect(state, { assetId, months }) {
  const next = cloneState(state);
  const h = next.holdings.find((x) => x.assetId === assetId);
  if (!h) return next;

  const premiumIRR = calcPremiumIRR({ assetId, notionalIRR: h.valueIRR, months });
  next.cashIRR = Math.max(0, next.cashIRR - premiumIRR);
  return next;
}

export function previewBorrow(state, { assetId, amountIRR, ltv }) {
  const next = cloneState(state);
  const h = next.holdings.find((x) => x.assetId === assetId);
  if (!h) return next;

  h.frozen = true;
  next.cashIRR += amountIRR;

  const liquidationIRR = calcLiquidationIRR({ amountIRR, ltv });
  const todayISO = new Date().toISOString().slice(0, 10);
  next.loan = { amountIRR, collateralAssetId: assetId, ltv, liquidationIRR, startISO: todayISO };

  return next;
}

export function previewRepay(state, { amountIRR }) {
  const next = cloneState(state);
  if (!next.loan) return next;

  const repay = Math.min(amountIRR, next.cashIRR, next.loan.amountIRR);
  next.cashIRR -= repay;
  next.loan.amountIRR -= repay;

  if (next.loan.amountIRR <= 0) {
    const collateral = next.holdings.find((x) => x.assetId === next.loan.collateralAssetId);
    if (collateral) collateral.frozen = false;
    next.loan = null;
  }
  return next;
}

/**
 * Deterministic rebalance for prototype:
 * - If mode includes cash: deploy cash into underweight layers.
 * - Never sells frozen collateral.
 * - Leaves residual drift if constrained.
 */
export function previewRebalance(state, { mode }) {
  const next = cloneState(state);
  const snap = computeSnapshot(next);
  const holdingsTotal = snap.holdingsIRR || 1;

  // Target values based on holdings only (cash excluded from layer calc)
  const targetIRR = {
    FOUNDATION: (state.targetLayerPct.FOUNDATION / 100) * holdingsTotal,
    GROWTH: (state.targetLayerPct.GROWTH / 100) * holdingsTotal,
    UPSIDE: (state.targetLayerPct.UPSIDE / 100) * holdingsTotal,
  };

  const curIRR = { ...snap.layerIRR };

  if (mode === "HOLDINGS_PLUS_CASH" && next.cashIRR > 0) {
    // Recalculate target based on total after deploying cash
    const newTotal = holdingsTotal + next.cashIRR;
    const newTargetIRR = {
      FOUNDATION: (state.targetLayerPct.FOUNDATION / 100) * newTotal,
      GROWTH: (state.targetLayerPct.GROWTH / 100) * newTotal,
      UPSIDE: (state.targetLayerPct.UPSIDE / 100) * newTotal,
    };

    const deficits = {
      FOUNDATION: Math.max(0, newTargetIRR.FOUNDATION - curIRR.FOUNDATION),
      GROWTH: Math.max(0, newTargetIRR.GROWTH - curIRR.GROWTH),
      UPSIDE: Math.max(0, newTargetIRR.UPSIDE - curIRR.UPSIDE),
    };

    const totalDef = deficits.FOUNDATION + deficits.GROWTH + deficits.UPSIDE;
    if (totalDef > 0) {
      const spend = Math.min(next.cashIRR, totalDef);

      const spendByLayer = {
        FOUNDATION: spend * (deficits.FOUNDATION / totalDef),
        GROWTH: spend * (deficits.GROWTH / totalDef),
        UPSIDE: spend * (deficits.UPSIDE / totalDef),
      };

      for (const layer of Object.keys(spendByLayer)) {
        const portion = spendByLayer[layer];
        if (portion <= 0) continue;

        const assets = next.holdings.filter((h) => ASSET_LAYER[h.assetId] === layer);
        if (!assets.length) continue;

        const per = portion / assets.length;
        for (const h of assets) h.valueIRR += per;
      }

      next.cashIRR -= spend;
    }
  }

  // No sell-based rebalancing in prototype; residual drift is expected and must be surfaced by boundary/status.
  return next;
}
```

---

## 5) Reducer (Authoritative, Impossible to Bypass)

**All actions must follow the same pipeline:**
`PREVIEW_* → pendingAction → CONFIRM_PENDING → ledger entry`

`src/state/reducer.js`

```js
import { computeSnapshot } from "../engine/snapshot.js";
import { classifyActionBoundary, frictionCopyForBoundary } from "../engine/boundary.js";
import {
  validateAddFunds,
  validateTrade,
  validateProtect,
  validateBorrow,
  validateRepay,
  validateRebalance,
} from "../engine/validate.js";
import {
  cloneState,
  previewAddFunds,
  previewTrade,
  previewProtect,
  previewBorrow,
  previewRepay,
  previewRebalance,
} from "../engine/preview.js";
import { calcPremiumIRR } from "../engine/pricing.js";

function uid() {
  return `${Math.random().toString(16).slice(2)}-${Date.now().toString(16)}`;
}

function nowISO() {
  return new Date().toISOString();
}

function buildPending(state, kind, payload, validation, afterState) {
  const before = computeSnapshot(state);
  const after = computeSnapshot(afterState);
  const boundary = classifyActionBoundary({
    kind,
    validation,
    before,
    after,
    stressMode: state.stressMode,
  });

  return {
    kind,
    payload,
    before,
    after,
    validation,
    boundary,
    frictionCopy: frictionCopyForBoundary(boundary),
  };
}

export function reducer(state, action) {
  switch (action.type) {
    // Global toggle (manual only — no auto-trigger until price feeds exist)
    case "SET_STRESS_MODE":
      return { ...state, stressMode: Boolean(action.payload?.on) };

    // --- Onboarding ---
    case "SET_PHONE": {
      const phone = String(action.payload?.phone || "").trim();
      if (!phone.startsWith("+989") || phone.length !== 13) return state;
      return { ...state, phone, stage: "ONBOARDING_QUESTIONNAIRE" };
    }

    case "SUBMIT_QUESTIONNAIRE": {
      const t = action.payload?.targetLayerPct;
      if (!t) return state;
      return { ...state, targetLayerPct: t, stage: "ONBOARDING_RESULT" };
    }

    case "ACCEPT_ALLOCATION":
      return { ...state, stage: "ACTIVE" };

    // --- Preview Actions ---
    case "PREVIEW_ADD_FUNDS": {
      const payload = { amountIRR: Number(action.payload?.amountIRR) };
      const validation = validateAddFunds(payload);
      const afterState = validation.ok ? previewAddFunds(state, payload) : cloneState(state);
      return { ...state, pendingAction: buildPending(state, "ADD_FUNDS", payload, validation, afterState) };
    }

    case "PREVIEW_TRADE": {
      const payload = {
        side: action.payload?.side,
        assetId: action.payload?.assetId,
        amountIRR: Number(action.payload?.amountIRR),
      };
      const validation = validateTrade(payload, state);
      const afterState = validation.ok ? previewTrade(state, payload) : cloneState(state);
      return { ...state, pendingAction: buildPending(state, "TRADE", payload, validation, afterState) };
    }

    case "PREVIEW_PROTECT": {
      const payload = { assetId: action.payload?.assetId, months: Number(action.payload?.months) };
      const validation = validateProtect(payload, state);
      const afterState = validation.ok ? previewProtect(state, payload) : cloneState(state);
      return { ...state, pendingAction: buildPending(state, "PROTECT", payload, validation, afterState) };
    }

    case "PREVIEW_BORROW": {
      const payload = {
        assetId: action.payload?.assetId,
        amountIRR: Number(action.payload?.amountIRR),
        ltv: Number(action.payload?.ltv),
      };
      const validation = validateBorrow(payload, state);
      const afterState = validation.ok ? previewBorrow(state, payload) : cloneState(state);
      return { ...state, pendingAction: buildPending(state, "BORROW", payload, validation, afterState) };
    }

    case "PREVIEW_REPAY": {
      const payload = { amountIRR: Number(action.payload?.amountIRR) };
      const validation = validateRepay(payload, state);
      const afterState = validation.ok ? previewRepay(state, payload) : cloneState(state);
      return { ...state, pendingAction: buildPending(state, "REPAY", payload, validation, afterState) };
    }

    case "PREVIEW_REBALANCE": {
      const payload = { mode: action.payload?.mode };
      const validation = validateRebalance(payload);
      const afterState = validation.ok ? previewRebalance(state, payload) : cloneState(state);
      return { ...state, pendingAction: buildPending(state, "REBALANCE", payload, validation, afterState) };
    }

    case "CANCEL_PENDING":
      return { ...state, pendingAction: null };

    // --- Confirm ---
    case "CONFIRM_PENDING": {
      const p = state.pendingAction;
      if (!p || !p.validation.ok) return state;

      let next = cloneState(state);

      // Commit by replaying deterministic preview
      if (p.kind === "ADD_FUNDS") next = previewAddFunds(next, p.payload);
      if (p.kind === "TRADE") next = previewTrade(next, p.payload);
      if (p.kind === "BORROW") next = previewBorrow(next, p.payload);
      if (p.kind === "REPAY") next = previewRepay(next, p.payload);
      if (p.kind === "REBALANCE") next = previewRebalance(next, p.payload);

      if (p.kind === "PROTECT") {
        const holding = next.holdings.find((h) => h.assetId === p.payload.assetId);
        if (holding) {
          const premium = calcPremiumIRR({
            assetId: holding.assetId,
            notionalIRR: holding.valueIRR,
            months: p.payload.months,
          });
          next.cashIRR -= premium;

          const startISO = new Date().toISOString().slice(0, 10);
          const end = new Date();
          end.setMonth(end.getMonth() + p.payload.months);
          const endISO = end.toISOString().slice(0, 10);

          next.protections = [
            ...next.protections,
            {
              id: uid(),
              assetId: holding.assetId,
              notionalIRR: holding.valueIRR,
              premiumIRR: premium,
              startISO,
              endISO,
            },
          ];
        }
      }

      const entry = {
        id: uid(),
        tsISO: nowISO(),
        type: `${p.kind}_COMMIT`,
        details: {
          kind: p.kind,
          payload: p.payload,
          boundary: p.boundary,
          validation: p.validation,
          before: p.before,
          after: computeSnapshot(next),
        },
      };

      next.pendingAction = null;
      next.ledger = [...next.ledger, entry];
      return next;
    }

    default:
      return state;
  }
}
```

---

## 6) UI Contract (Impossible to Misinterpret)

UI must **only**:

1. Collect inputs
2. Dispatch `PREVIEW_*`
3. Render `state.pendingAction`
4. Dispatch `CONFIRM_PENDING` or `CANCEL_PENDING`

UI must **never**:

- Compute boundaries
- Compute premiums
- Modify holdings/cash/loan/protections
- Invent chat responses beyond deterministic copy

### 6.1 Required PendingAction UI

When `pendingAction` exists, show:

- Action summary (kind + payload)
- Mechanical validation errors (if any) + disable confirm
- Boundary label (SAFE/DRIFT/STRUCTURAL/STRESS)
- frictionCopy lines
- Minimal deltas (cash change + layer % change)

No "chatty" explanations.

### 6.2 Cash Display

Cash is displayed **separately** from layer allocation:

```
┌─────────────────────────────────────┐
│  Cash: 50,000,000 IRR               │
├─────────────────────────────────────┤
│  Foundation: 45%  ████████░░░░      │
│  Growth:     40%  ████████░░░░      │
│  Upside:     15%  ███░░░░░░░░░      │
└─────────────────────────────────────┘
```

Layer percentages reflect **invested holdings only**.

---

## 7) Per-Action Wiring (Exact)

### 7.1 Add Funds

- Dispatch: `PREVIEW_ADD_FUNDS { amountIRR }`
- Validation: amount must be positive number
- Confirm: `CONFIRM_PENDING`
- Commit: cash increases
- Ledger: `ADD_FUNDS_COMMIT`

### 7.2 Trade (Buy/Sell)

- Dispatch: `PREVIEW_TRADE { side, assetId, amountIRR }`
- Mechanical errors:
  - BUY: `INSUFFICIENT_CASH`
  - SELL: `ASSET_FROZEN` or `INSUFFICIENT_ASSET_VALUE`
- Commit: cash/holding change
- Ledger: `TRADE_COMMIT`

### 7.3 Protect

- Dispatch: `PREVIEW_PROTECT { assetId, months }`
- Mechanical errors (all at preview time):
  - `INVALID_MONTHS`, `NO_NOTIONAL`, `INVALID_ASSET`
  - `INSUFFICIENT_CASH_FOR_PREMIUM`
- Commit: cash decreases by premium + protections append
- Ledger: `PROTECT_COMMIT`

### 7.4 Borrow

- Dispatch: `PREVIEW_BORROW { assetId, amountIRR, ltv }`
- Mechanical errors:
  - `LOAN_ALREADY_ACTIVE`, `ASSET_ALREADY_FROZEN`, `EXCEEDS_MAX_BORROW`
- Commit: collateral frozen + loan created + cash credited
- Ledger: `BORROW_COMMIT`

### 7.5 Repay

- Dispatch: `PREVIEW_REPAY { amountIRR }`
- Mechanical errors:
  - `NO_ACTIVE_LOAN`, `NO_CASH`
- Commit: cash decreases; loan decreases; if 0 then unlock collateral and clear loan
- Ledger: `REPAY_COMMIT`

### 7.6 Rebalance

- Dispatch: `PREVIEW_REBALANCE { mode: HOLDINGS_ONLY | HOLDINGS_PLUS_CASH }`
- Commit: deterministic rebalance (cash deployment only in prototype)
- Boundary: SAFE only if issues improve; otherwise STRUCTURAL (residual drift shows constraints)
- Ledger: `REBALANCE_COMMIT`

---

## 8) File Layout (Locked)

```
src/
  state/
    domain.js          # ASSETS, ASSET_LAYER, LAYER_RANGES
    initialState.js    # Initial app state
    reducer.js         # All state transitions
  engine/
    snapshot.js        # computeSnapshot (cash excluded from layers)
    portfolioStatus.js # BALANCED/SLIGHTLY_OFF/ATTENTION_REQUIRED
    validate.js        # Mechanical validation (including premium check)
    pricing.js         # Prototype pricing functions
    boundary.js        # Action boundary classification
    preview.js         # Pure preview simulators
  data/
    questionnaire.fa.json
  ui/
    AppShell.jsx
    ChatPanel.jsx
    PortfolioHome.jsx
    PendingActionModal.jsx
```

**App entrypoint imports only:**

- `initialState`
- `reducer`
- UI components

No engine logic inside UI components.

---

## 9) Acceptance Criteria

Refactor is complete when:

1. There is exactly **one** reducer and it drives the UI.
2. Every action flows through:
   `PREVIEW_* → pendingAction → CONFIRM_PENDING → ledger`
3. Removing business logic from UI components does not change behavior.
4. A dev can add a new action by implementing:
   `validateX`, `previewX`, wiring `PREVIEW_X`, commit branch + ledger
   without reworking the architecture.
5. Cash is displayed separately from layer allocation.
6. User with only cash shows 0% in all layers (not counted as Foundation).
7. PREVIEW_PROTECT fails immediately if insufficient cash for premium.

---

## 10) Out of Scope (Explicit)

- Real pricing feeds, P&L charts
- Real hedge instruments
- Multi-loan support
- Auto-adjusting target allocation
- Sell-based rebalance beyond deterministic cash deployment
- Auto-triggered stressMode (requires price feeds)

These can be added later without changing the action pipeline.

---

## 11) Key Decisions Log

| Decision | Choice | Rationale |
|----------|--------|-----------|
| ETH layer | Upside | Less established than BTC, higher volatility |
| Cash in allocation | Excluded | Layer % reflects invested holdings only |
| Premium validation | At preview | Immediate feedback, no surprise rejection |
| stressMode trigger | Manual only | No price feeds yet |
